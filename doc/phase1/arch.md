We are planning to split the scope of this project between two backends. One of the backends will handle all the operations uniquely performed by professors. For example, it will handle course / lecture section creation and office hour scheduling. The other backend will handle all operations uniquely performed by students. This web app will handle booking meetings, and commenting on these meetings once they are created. Obviously there are some operations, such as getting the list of office hours for a lecture section, which both professors and students need to perform. We will take these operations on a case-by-case basis.

The client code will all be inside one react web app, with different views for our two different user types. After login, the user will have access to only the views appropriate for their user type.

We chose to split the scope of this project in such a way, because there are clearly two different user types with mostly separate use cases. We thought it might be easier to get the security configuration correct, and it would cut down on boilerplate, if we guarantee a professor can do all operations in one web app and a student can do all operations in the other. That way we won't need to check user role as often when performing security verification.

Our frontend is programmed in React.js, because we thought there would be many repeating elements in our UI which we could abstract out using React components (for example, time slots in the calendar). We started with a frontend project generated using the CLI tool create-react-app, simply because it was fast and easy. We are using Apollo Client to handle our GraphQL requests in the frontend. We tried making GraphQL requests manually using a hacky solution involving string manipulation and the builtin Javascript fetch() method, but we agreed that the Apollo API is easy to work with and much more readable.

Our backend is programmed in Python, using Flask as a web framework, and graphene to help handle GraphQL. We are using GraphQL instead of REST because it has a type system that works across front and back end, making it easier to communicate between them. It also greatly speeds up back end development since we do not need to design individual REST endpoints anymore. We are choosing Flask over Django to serve our GraphQL endpoint, since we are following the ports and adapters architecture for our back end, and Django would bleed too much framework cruft into the core of our application.

